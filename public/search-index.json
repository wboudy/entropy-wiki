[
  {
    "id": "beads",
    "title": "README",
    "content": "Beads System Manual Version: 1.0 Purpose: Technical reference for AI agents managing persistent memory and multi-session work  Overview Beads is a git-backed issue tracking system designed for AI agents to maintain context across conversation sessions, manage dependencies, and coordinate complex multi-session work. This manual serves as training data for understanding beads workflows and memory management.  Core Concepts What is a Bead? - A persistent work item tracked across sessions - Stored in  directory as structured data - Version-controlled via git for history and collaboration - Supports dependencies, blocking relationships, and priority When to Use Beads vs TodoWrite: - Use Beads for:   - Multi-session work that spans conversations   - Tasks with blocking dependencies   - Strategic work requiring context recovery after compaction   - Discovered work that needs tracking beyond current session - Use TodoWrite for:   - Simple single-session execution   - Immediate task breakdown w",
    "url": "/beads",
    "category": "beads"
  },
  {
    "id": "beads/cli-reference",
    "title": "cli-reference",
    "content": "CLI Reference: bd Command Complete reference for the  command-line interface.  Command Structure  Global Options Available for all commands: -  - Show help for command -  - Show beads version ---  Core Commands   Initialize beads in the current project. What it does: - Creates  directory structure - Initializes config and index files - Sets up git integration - Configures hooks When to use: - First-time setup in a new repository - After cloning a repo without beads ---   Create a new issue. Options: -  - Issue title (required) -  - Issue type: , , ,  (default: ) -  - Priority: 0-4 or P0-P4 (0=critical, 4=backlog, default: 2) -  - Assign to user -  - Issue description -  - Associate with epic Examples: Parallel Creation: For efficiency when creating multiple issues, use parallel subagents. ---   List issues with optional filters. Options: -  - Filter by status: , , ,  -  - Filter by type: , , ,  -  - Filter by priority: 0-4 or P0-P4 -  - Filter by assignee -  - Show issues in epic Examp",
    "url": "/beads/cli-reference",
    "category": "beads"
  },
  {
    "id": "beads/dependencies",
    "title": "dependencies",
    "content": "Dependency Resolution  Overview Beads uses a dependency graph to model blocking relationships between issues. Dependencies enable: - Explicit ordering constraints (\"A must complete before B\") - Automatic priority surfacing via PageRank - Blocking/unblocking cascade detection - Strategic work sequencing  Dependency Model  Terminology Dependency Relationship: Graph Representation: - Nodes: Individual issues - Edges: Dependency relationships (directed) - Direction: Edge points from dependent to dependency   -  means \"A depends on B\" (B blocks A)  Dependency Commands Add Dependency: Remove Dependency: View Dependencies:  PageRank-Based Priority  Why PageRank? Traditional priority systems (P0-P4) are static and don't account for strategic impact. PageRank dynamically calculates importance based on how many issues a given issue unblocks. Core Insight: Issues that unblock many other issues should be prioritized, even if their nominal priority is lower.  How It Works 1. Graph Construction:    ",
    "url": "/beads/dependencies",
    "category": "beads"
  },
  {
    "id": "beads/lifecycle",
    "title": "lifecycle",
    "content": "Bead Lifecycle  State Model A bead progresses through discrete states that represent its position in the work pipeline. Understanding these states is critical for effective memory management and work coordination.  States  1. Open (Initial State) Meaning: Issue has been created but work has not started. Characteristics: - Newly created issues start here - Available for assignment - May have dependencies (blockers) - Visible in  Valid Transitions: - →  (work begins) - →  (cancelled or determined unnecessary) Commands:  2. In Progress (Active Work) Meaning: An agent or human is actively working on this issue. Characteristics: - Indicates current focus area - Should have assignee - One agent should work on one issue at a time - Visible in  Valid Transitions: - →  (dependency or external blocker discovered) - →  (work completed) - →  (work paused/reassigned) Commands:  3. Blocked (Waiting) Meaning: Work cannot proceed due to dependencies or external factors. Characteristics: - Has explicit",
    "url": "/beads/lifecycle",
    "category": "beads"
  },
  {
    "id": "beads/workflows",
    "title": "workflows",
    "content": "Common Workflows Practical patterns for using beads effectively in different scenarios.  Daily Development Flow  Morning: Finding Work  During Work: Discovering Dependencies  End of Day: Wrapping Up ---  Feature Development Workflow  Phase 1: Planning  Phase 2: Execution  Phase 3: Completion ---  Bug Fix Workflow  Rapid Fix (Single Session)  Complex Bug (Multi-Session) ---  Refactoring Workflow  Incremental Refactor ---  Blocked Work Recovery  Scenario: External Blocker ---  Collaboration Workflow  Taking Over Work  Sync and Conflict Resolution ---  Context Recovery Workflow  After Conversation Compaction  After Long Break ---  Strategic Planning Workflow  Epic with Parallel Tracks ---  Maintenance Workflow  Weekly Cleanup  Monthly Audit ---  Anti-Patterns to Avoid  1. Too Many In-Progress Issues Bad: Good:  2. Ignoring Dependencies Bad: Good:  3. Manual Priority Override Bad: Good:  4. Creating Without Planning Bad: Good:  5. Not Using Comments Bad: Good: ---  Summary: Key Principles ",
    "url": "/beads/workflows",
    "category": "beads"
  },
  {
    "id": "gastown",
    "title": "README",
    "content": "Gastown Documentation Multi-agent orchestration system for Claude Code with persistent work tracking.  Overview Gastown is a workspace manager that coordinates multiple AI agents working on different tasks. Instead of losing context when agents restart, Gastown persists work state in git-backed hooks, enabling reliable multi-agent workflows. This directory contains comprehensive documentation for implementing and operating Gastown rigs.  Documentation  GUPP - Gastown Unified Propulsion Protocol ⭐ The Industrial Constitution of a Gastown Rig Comprehensive guide covering: - Philosophy of Momentum - Core principles for continuous propulsion - Rig Hierarchy - Roles from Human Overseer to Polecats - Coordination Patterns - Sequential, parallel, and escalation workflows - Troubleshooting - Handling \"Ralph Wiggum States\" (degraded agents) - Metrics & Health - KPIs and monitoring procedures Essential reading for: - Human operators setting up or managing Gastown rigs - AI agents (Mayor, Polecat",
    "url": "/gastown",
    "category": "gastown"
  },
  {
    "id": "gastown/gupp",
    "title": "gupp",
    "content": "GUPP: The Gastown Unified Propulsion Protocol The Industrial Constitution of a Gastown Rig Version 1.0 | Philosophy of Momentum for Multi-Agent Coordination ---  Executive Summary GUPP (Gastown Unified Propulsion Protocol) is the operational philosophy and structural framework that governs multi-agent coordination in Gastown rigs. It embodies a philosophy of momentum: systems should always be moving forward, agents should never be idle when work exists, and blockers must be resolved through systematic escalation and delegation. This document serves as the industrial constitution for Gastown operations, defining: - The Rig Hierarchy (roles and responsibilities) - The philosophy of continuous propulsion - Multi-agent coordination patterns - Troubleshooting procedures for degraded states Target Audience: Human operators, AI agents (Mayor, Polecats), and system architects implementing Gastown workflows. ---  Part I: Philosophy of Momentum  Core Principle Momentum is the default state. Idle",
    "url": "/gastown/gupp",
    "category": "gastown"
  },
  {
    "id": "gastown/monitor",
    "title": "monitor",
    "content": "Rig Health Manual: Gauges and Dials Monitoring and Diagnostics for Gastown Rigs Version 1.0 | The Operator's Guide to Rig Telemetry ---  Overview A healthy Gastown rig is like a well-tuned engine: you can feel the rhythm of progress. Issues flow in, agents consume them, work gets completed, and the ledger drains. When the rig stalls or stutters, the gauges tell you why. This manual explains how to monitor your rig's health using the Beads Viewer (bv) and command-line tools. You'll learn to interpret the key metrics that indicate rig vitality: - PageRank - Task importance and unblocking priority - Critical Paths - Bottlenecks preventing progress - Cycle Detection - Logic loops causing infinite dependencies - Pulse - The rhythm indicating whether work is flowing or stalled Target Audience: Human Overseers, Mayors (AI coordinators), and system operators monitoring Gastown rigs. ---  Part I: The Beads Viewer (bv)  What is bv? The Beads Viewer is a terminal-based UI (TUI) for visualizing an",
    "url": "/gastown/monitor",
    "category": "gastown"
  },
  {
    "id": "orchestration",
    "title": "README",
    "content": "Orchestration Multi-agent coordination patterns and handoff protocols.  What is Orchestration? Orchestration defines how multiple AI agents work together to solve complex problems. It covers task distribution, state management, and agent-to-agent communication.  Core Concepts Key orchestration patterns include: - Sequential workflows (agent chains) - Parallel execution (concurrent tasks) - Hierarchical coordination (supervisor/worker) - Event-driven handoffs  Protocols This section documents: - Handoff protocols between agents - State synchronization patterns - Error handling and recovery - Performance optimization strategies Use these patterns to build robust multi-agent systems that coordinate effectively and handle failures gracefully.",
    "url": "/orchestration",
    "category": "orchestration"
  },
  {
    "id": "orchestration/claude-code-multi-agent-workflow",
    "title": "claude-code-multi-agent-workflow",
    "content": "Beads + Claude Code: Multi-Agent Workflow Architecture > VER: 1.0.0 > STATUS: Production > LASTUPDATED: 2026-01-08  Question How should we coordinate terminal (bd CLI) and Claude Code when working through epics? One agent per epic, or multiple agents per epic? ---  Answer: Multiple Agents Per Epic (Dependency-Driven Parallelism) Beads is explicitly designed for multi-session AI agent workflows where: - Multiple Claude Code agents work in parallel on different tasks within the same epic - Terminal serves as coordination point for planning and monitoring - Dependencies define execution order, not manual sequencing - Context survives across sessions via git-backed persistence ---  Core Design Philosophy > \"Beads is a git-backed issue tracking system designed for AI agents to maintain context across conversation sessions, manage dependencies, and coordinate complex multi-session work.\" > > —   Key Principle: Persistence Over Optimization - When in doubt, track it in beads - Conversations a",
    "url": "/orchestration/claude-code-multi-agent-workflow",
    "category": "orchestration"
  },
  {
    "id": "prompt-bank",
    "title": "README",
    "content": "Prompt Bank High-performance, battle-tested prompts for AI agents and LLMs.  What is Prompt Bank? Prompt Bank is a curated collection of effective prompts organized by use case. Each prompt is optimized for clarity, specificity, and reliable output.  Categories Prompts are categorized by: - Task type (generation, analysis, refactoring, etc.) - Domain (code, documentation, data processing) - Complexity level  Usage Each prompt includes: - Clear objective statement - Input format requirements - Expected output structure - Example usage Browse the collection to find prompts that fit your workflow, or use them as templates for custom variations.",
    "url": "/prompt-bank",
    "category": "prompt-bank"
  },
  {
    "id": "prompt-bank/the-refiner",
    "title": "the-refiner",
    "content": "THEREFINER || VER: 1.0.2 > [!NOTE] > Golden prompt for turning rough intent into high-density Gastown-style instructions.  Prompt > [!TIP] > Pair with a domain preface to enforce tone, constraints, and stack context. > [!CAUTION] > Do not leak hidden chain-of-thought. Summaries only.",
    "url": "/prompt-bank/the-refiner",
    "category": "prompt-bank"
  },
  {
    "id": "skills-bank",
    "title": "README",
    "content": "Skills Bank A collection of reusable AI agent capabilities and skill definitions.  What is Skills Bank? Skills Bank provides modular, plug-and-play capabilities for AI agents. Each skill is a self-contained unit that can be deployed, tested, and reused across different contexts.  Structure Skills are organized by capability type and include: - Skill templates - Implementation patterns - Testing strategies - Integration guides  Getting Started Browse the available skills to find capabilities that match your needs. Each skill includes clear documentation on usage, dependencies, and examples.",
    "url": "/skills-bank",
    "category": "skills-bank"
  },
  {
    "id": "skills-bank/template-skill",
    "title": "template-skill",
    "content": "SKILLTEMPLATE || VER: 1.0.2 > [!NOTE] > Use this template to define a skill with maximum operational clarity.  Metadata - Name: - Owner: - Domain: - Version: - Status: draft | active | deprecated - Last Updated:  Inputs - Required: - Optional: - Constraints:  Outputs - Primary: - Secondary: - Quality Gates:  Required Tools - Local: - External: - MCP:  Logic Flow 1.  2.  3.   Edge Cases -   Verification -  > [!TIP] > Keep logic flow executable. If a step can't be performed, delete it. > [!CAUTION] > Avoid cross-skill dependencies unless they are version-pinned.",
    "url": "/skills-bank/template-skill",
    "category": "skills-bank"
  },
  {
    "id": "tooling-mcp",
    "title": "README",
    "content": "Tooling & MCP MCP server configurations and custom tool definitions for AI agents.  What is MCP? Model Context Protocol (MCP) provides a standardized way to connect AI agents to external tools, data sources, and services.  Contents This section includes: - MCP server configurations - Custom tool definitions - Integration patterns - Connection examples  Getting Started MCP enables AI agents to interact with: - File systems - Databases - APIs and web services - Development tools - Custom business logic Each tool definition includes schema, usage examples, and configuration guidance.",
    "url": "/tooling-mcp",
    "category": "tooling-mcp"
  },
  {
    "id": "tooling-mcp/mcp-standard",
    "title": "mcp-standard",
    "content": "MCPSTANDARD || VER: 1.0.2 > [!NOTE] > Purpose: Document and share MCP server configurations between two operators with zero ambiguity.  Required Sections - Server Identity: Name, owner, repo, contact. - Runtime: Node/Python version, OS target, start command. - Capabilities: Tools, resources, prompts exposed. - Auth: Tokens, scopes, rotation policy. - Network: Ports, endpoints, CORS rules. - Security: Sandboxing, file access, secrets storage. - Change Log: Version, date, breaking changes.  Share Protocol 1. Export server config and tool schema. 2. Redact secrets; replace with placeholders. 3. Provide a verified start command and health check. 4. Sync via repo PR or direct file drop in . > [!TIP] > Include one minimal usage example per tool. Keep outputs deterministic. > [!CAUTION] > Never paste real keys. Use  placeholders and describe where they live.",
    "url": "/tooling-mcp/mcp-standard",
    "category": "tooling-mcp"
  }
]